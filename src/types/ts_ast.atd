type node_flags <ocaml module="Flags"> = abstract
type symbol_flags <ocaml module="Flags"> = abstract
type type_flags <ocaml module="Flags"> = abstract
type object_flags <ocaml module="Flags"> = abstract
type symbol_id <ocaml module="Ts_ids"> = abstract
type type_id <ocaml module="Ts_ids"> = abstract
type node_id <ocaml module="Ts_ids"> = abstract
type syntax_kind_name <ocaml from="Ts_syntax_kind" t="t"> = abstract

(* (string * string) <json repr="object"> *)
type syntax_kind = int


(*
  Symbols
*)

type symbol = {
    flags: symbol_flags ;
    name: string ;
    escapedName: string ;
    fullyQualifiedName: string ;
    ?aliasedSymbol: symbol_id option ;
    ?exportSymbol: symbol_id option ;
    ?valueDeclaration: node_id option ;
    declarations: node_id list ;
    members: symbol_id list ;
    declaredType: type_id;
    id: symbol_id;
}

(*
  Nodes
*)

type node = [
  | TypeParameter of node_generic
  | InterfaceDeclaration of node_generic
  | TypeAliasDeclaration of node_generic
  | ModuleBlock of node_generic
  | NamespaceDeclaration of node_generic
  | ModuleDeclaration of node_generic
  | Identifier of identifier
  | StringLiteral of stringLiteral
  | NumericLiteral of numericLiteral
  | SourceFile of sourceFile
  | Generic <json untyped> of (string * node_generic)
] <json adapter.ocaml="Ts_ast_json_adapters.KindName">
type node_modifier = [
  | AbstractKeyword of node_generic
  | AsyncKeyword of node_generic
  | ConstKeyword of node_generic
  | DeclareKeyword of node_generic
  | DefaultKeyword of node_generic
  | ExportKeyword of node_generic
  | PrivateKeyword of node_generic
  | ProtectedKeyword of node_generic
  | PublicKeyword of node_generic
  | ReadonlyKeyword of node_generic
  | StaticKeyword of node_generic
] <json adapter.ocaml="Ts_ast_json_adapters.KindName">
type node_generic = {
  kind: int;
  kindName: string;
  flags: node_flags;
  ?parent: node_id option ;
}

type identifier = {
  kindName: string ;
  flags: node_flags ;
  kind: syntax_kind ;
  ?originalKeywordKind: syntax_kind option ;
  escapedText: string ;
}
type stringLiteral = {
  text: string ;
  ?isUnterminated: bool option ;
  ?hasExtendedUnicodeEscape: bool option ;
  kindName: string ;
  flags: node_flags ;
  kind: syntax_kind ;
}
type numericLiteral = {
  text: string ;
  ?isUnterminated: bool option ;
  ?hasExtendedUnicodeEscape: bool option ;
  kindName: string ;
  flags: node_flags ;
  ?parent: node option ;
  kind: syntax_kind
}

(*
  Statements
*)

type statements = [
  | SourceFile of sourceFile
  | TypeParameter of node_generic
] <json adapter.ocaml="Ts_ast_json_adapters.KindName">

type declarationName = [
  | StringLiteral of stringLiteral
  | Identifier of identifier
  | NumericLiteral of numericLiteral
  | PrivateIdentifier
  | ComputedPropertyName
  | ElementAccessExpression
  | BindingPattern
  | EntityNameExpression
] <json adapter.ocaml="Ts_ast_json_adapters.KindName">

type sourceFile = {
  kind: syntax_kind ;
  kindName: string ;
  flags: node_flags ;
  ?parent: node option ;
  filePath: string ;
  baseName: string ;
  baseNameWithoutExtension: string ;
  extension: string ;
  scriptKind: int ;
  isDeclarationFile: bool ;
  isFromExternalLibrary: bool ;
  isInNodeModules: bool ;
  fullSource: string ;
  symbols: symbol_id list ;
  statements: node_id list ;
}

type declarationWithTypeParameterChildren = node_generic
type typeParameterDeclaration = {
  flags: node_flags ;
  ?symbol: symbol option ;
  kind: syntax_kind ;
  kindName: string ;
  ?name: declarationName option ;
  ?parent: declarationWithTypeParameterChildren option ;
  ?constraint_ <json name="constraint">: node option ;
  ?default: node option;
}
type typeAliasDeclaration = {
  flags: node_flags ;
  ?parent: node option ;
  ?symbol: symbol option ;
  kind: syntax_kind ;
  kindName: string ;
  ?name: declarationName option ;
  ?parameters: typeParameterDeclaration list option;
  ?type_ <json name="type">: type_ option ;
  ?modifiers: node_modifier list option ;
}

(*
  Result
*)
type result = {
  ?errors: string option;
  symbols: (symbol_id * symbol) list;
  nodes: (node_id * node) list;
  types: (type_id * type_) list;
  sourceFiles: (string * node_id) list;
}

(*
  Not quite types
*)

type destructuringPattern =
  [ BindingPattern  | ObjectLiteralExpression  | ArrayLiteralExpression ]

type bindingPattern = [ ObjectBindingPattern  | ArrayBindingPattern ]
type arrayBindingElement = [ BindingElement  | OmittedExpression ]
type propertyLikeDeclaration = {
  name: node_id ;
}
type objectBindingPattern = {
  (* kind: syntaxKind_ObjectBindingPattern ; *)
  kind: syntax_kind_name ;
  parent:
    [ VariableDeclaration  | ParameterDeclaration  | BindingElement ] ;
  elements: node list ;
}
type arrayBindingPattern = {
  kind: [ ArrayBindingPattern ] ;
  parent:
    [ VariableDeclaration  | ParameterDeclaration  | BindingElement ] ;
  elements: arrayBindingElement list
}

(*
  Types
*)

type type_ =
  {
  flags: type_flags ;
  id: int ;
  symbol: symbol_id ;
  ?pattern: destructuringPattern option ;
  ?aliasSymbol: symbol_id option ;
  ?aliasTypeArguments: type_id list option ;
  ?aliasTypeArgumentsContainsMarker: bool option ;
  ?permissiveInstantiation: type_id option ;
  ?restrictiveInstantiation: type_id option ;
  ?immediateBaseConstraint: type_id option ;
  ?widened: type_id option
}

